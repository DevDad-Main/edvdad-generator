import "dotenv/config";
import express from "express";
{{#if features.jwt}}
import { authRouter } from "./routes/auth.routes.js";
{{/if}}
import { errorHandler, logger, sendError } from "devdad-express-utils";
{{#if features.helmet}}
import helmet from "helmet";
{{/if}}
{{#if features.cors}}
import cors from "cors";
{{/if}}
import cookieParser from "cookie-parser";
{{#if features.redis}}
import { RateLimiterRedis } from "rate-limiter-flexible";
import redisClient from "./utils/redis.js";
{{/if}}
{{#if features.rateLimit}}
import rateLimit from "express-rate-limit";
{{#if features.redis}}
import RedisStore from "rate-limit-redis";
{{/if}}
{{/if}}
{{#if features.docs}}
import swaggerJsdoc from "swagger-jsdoc";
import swaggerUi from "swagger-ui-express";
{{/if}}

const app = express();

{{#if features.cors}}
const allowedOrigins = process.env.ALLOWED_ORIGINS ? process.env.ALLOWED_ORIGINS.split(",") : ["http://localhost:3000"];
{{/if}}

{{#if features.rateLimit}}
{{#if features.redis}}
const rateLimiter = new RateLimiterRedis({
  storeClient: redisClient,
  keyPrefix: "{{projectName}}-rate-limit-middleware",
  points: 10,
  duration: 1,
});
{{/if}}

const expressEndpointRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res, _next) => {
    {{#if features.logging}}
    logger.warn(`Public API Rate Limit Exceeded for IP: ${req.ip}`);
    {{/if}}
    return sendError(res, "Rate Limit Exceeded", 429);
  },
  {{#if features.redis}}
  store: new RedisStore({
    sendCommand: (...args) => redisClient.call(...args),
  }),
  {{/if}}
});
{{/if}}

{{#if features.docs}}
const swaggerOptions = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "{{projectName}} API",
      version: "1.0.0",
      description: "Generated backend API documentation",
    },
    servers: [
      {
        url: process.env.API_URL || `http://localhost:${process.env.PORT || 3000}`,
        description: "Development server",
      },
    ],
  },
  apis: ["./src/routes/*.js"], // paths to files containing OpenAPI definitions
};

const specs = swaggerJsdoc(swaggerOptions);
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(specs));
{{/if}}

// Middleware
{{#if features.helmet}}
app.use(helmet());
{{/if}}

{{#if features.cors}}
app.use(
  cors({
    origin: allowedOrigins,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
    ],
  }),
);
{{/if}}

app.use(express.json({ limit: "3mb" }));
app.use(cookieParser());

{{#if features.rateLimit}}
{{#if features.redis}}
app.use((req, res, next) => {
  rateLimiter
    .consume(req.ip)
    .then(() => next())
    .catch(() => {
      {{#if features.logging}}
      logger.warn(`Rate Limit Exceeded for IP: ${req.ip}`);
      {{/if}}
      return sendError(res, "Rate Limited Exceeded", 429);
    });
});
{{else}}
app.use(expressEndpointRateLimiter);
{{/if}}
{{/if}}

// Routes
{{#if features.jwt}}
app.use(
  "/api/auth",
  {{#if features.redis}}
  (req, res, next) => {
    req.redisClient = redisClient;
    next();
  },
  {{/if}}
  authRouter,
);
{{/if}}

// Health check endpoint
app.get("/health", (req, res) => {
  res.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

{{#if features.docs}}
/**
 * @swagger
 * /health:
 *   get:
 *     summary: Health check endpoint
 *     description: Returns the current status of the API
 *     responses:
 *       200:
 *         description: API is healthy
 */
{{/if}}

// Global Error Handler
app.use(errorHandler);

export default app;